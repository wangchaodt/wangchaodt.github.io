---
title: php-fmp到底是什么？
date: 2018-05-19 16:48:13
tags: [php,php-fpm,cgi]
categories: PHP
---
很多时候是php-fpm一直在用，但却不知道是干什么用的，所有今天会梳理一下，做一个整体的理解。整体一句话就是php-fpm是php-fastcgi的管理器，为php提供服务。
<!--more-->

## cgi

说到php-fastcgi就要了解什么是cgi？
网上普遍说法是 `通用网关接口` 就是一个通信协议，方便外部程序与web server质检交互的数据格式，他的一个执行流程是当web server 接收到一个请求之后，会启动相应的cgi进程(php就会启动php相应的cgi进程就是Fastcgi后面会讲到)，然后cgi会进行一系列的操作，然后将处理结果通过协议规定的格式返回，然后cgi进程会退出，最后web server会将结果返回给请求方，周而复始 请求->生成cgi->执行->退出。

* 当用户访问我们的 Web 应用时，会发起一个 HTTP 请求。最终 Web 服务器接收到这个请求
* Web 服务器创建一个新的 CGI 进程。在这个进程中，将 HTTP 请求数据已一定格式解析出来，并通过标准输入和环境变量传入到 URL 指定的 CGI 程序（PHP 应用 `$_SERVER`）
* Web 应用程序处理完成后将返回数据写入到标准输出中，Web 服务器进程则从标准输出流中读取到响应，并采用 HTTP 协议返回给用户响应

一句话就是 Web 服务器中的 CGI 进程将接收到的 HTTP 请求数据读取到环境变量中，通过标准输入转发给 PHP 的 CGI 程序；当 PHP 程序处理完成后，Web 服务器中的 CGI 进程从标准输出中读取返回数据，并转换回 HTTP 响应消息格式，最终将页面呈献给用户。然后 Web 服务器关闭掉这个 CGI 进程。

可以说 CGI 协议特别擅长处理 Web 服务器和 Web 应用的通信问题。然而，它有一个严重缺陷，对于每个请求都需要重新 fork 出一个 CGI 进程，处理完成后立即关闭。

## FastCgi
了解完cgi我们就知道cgi，在性能上可能不是很完美，他没接收一个请求都会生成一个cgi同时也是初始化相应的环境，这个就会比较耗时，这时候FastCgi的出现就是解决这个问题，他是其实就是cgi的优化版。FastCgi首先会启动一个master进程，解析配置文件和初始化环境，同时会启动很多个worker进程，每当有请求过来时，master会请求传递给一个worker，这样就不需要重复的初始化，加载等一系列的操作，当然系统繁忙是会多启动几个worker，当系统空闲是也会kill掉一部分的worker，当然这样也会长期占用一定的内存(但作为内存不值钱的今天，这点消耗微不足道)

* FastCGI 进程管理器启动时会创建一个 主（Master） 进程和多个 CGI 解释器进程（Worker 进程），然后等待 Web 服务器的连接
* Web 服务器接收 HTTP 请求后，将 CGI 报文通过 套接字（UNIX 或 TCP Socket）进行通信，将环境变量和请求数据写入标准输入,转发到 CGI 解释器进程
* CGI 解释器进程完成处理后将标准输出和错误信息从同一连接返回给 Web 服务器
* CGI 解释器进程等待下一个 HTTP 请求的到来

### FastCgi协议组成

#### 主要的消息头信息如下：
* Version：用于表示 FastCGI 协议版本号。
* Type：用于标识 FastCGI 消息的类型 - 用于指定处理这个消息的方法。
* RequestID：标识出当前所属的 FastCGI 请求。
* Content Length: 数据包包体所占字节数。

#### 消息类型定义
* <b>BEGIN_REQUEST</b>：从 Web 服务器发送到 Web 应用，表示开始处理新的请求。
* <b>ABORT_REQUEST</b>：从 Web 服务器发送到 Web 应用，表示中止一个处理中的请求。比如，用户在浏览器发起请求后按下浏览器上的「停止按钮」时，会触发这个消息。
* <b>END_REQUEST</b>：从 Web 应用发送给 Web 服务器，表示该请求处理完成。返回数据包里包含「返回的代码」，它决定请求是否成功处理。
* <b>PARAMS</b>：「流数据包」，从 Web 服务器发送到 Web 应用。此时可以发送多个数据包。发送结束标识为从 Web 服务器发出一个长度为 0 的空包。且 <b>PARAMS</b> 中的数据类型和 CGI 协议一致。即我们使用 <b>$_SERVER</b> 获取到的系统环境等
* <b>STDIN</b>：「流数据包」，用于 Web 应用从标准输入中读取出用户提交的 POST 数据
* <b>STDOUT</b>：「流数据报」，从 Web 应用写入到标准输出中，包含返回给用户的数据

#### Web服务器与FastCgi交互流程

* Web 服务器接收用户请求，但最终处理请求由 Web 应用完成。此时，Web 服务器尝试通过套接字（UNIX 或 TCP 套接字，具体使用哪个由 Web 服务器配置决定）连接到 FastCGI 进程
* FastCGI 进程查看接收到的连接。选择「接收」或「拒绝」连接。如果是「接收」连接，则从标准输入流中读取数据包
* 如果 FastCGI 进程在指定时间内没有成功接收到连接，则该请求失败。否则，Web 服务器发送一个包含唯一的 RequestID 的 BEGIN_REQUEST 类型消息给到 FastCGI 进程。后续所有数据包发送都包含这个 RequestID。 然后，Web 服务器发送任意数量的 PARAMS 类型消息到 FastCGI 进程。一旦发送完毕，Web 服务器通过发送一个空 PARAMS 消息包，然后关闭这个流。 另外，如果用户发送了 POST 数据 Web 服务器会将其写入到 标准输入（STDIN） 发送给 FastCGI 进程。当所有 POST 数据发送完成，会发送一个空的 标准输入（STDIN） 来关闭这个流
* 同时，FastCGI 进程接收到 BEGIN_REQUEST 类型数据包。它可以通过响应 END_REQUEST 来拒绝这个请求。或者接收并处理这个请求。如果接收请求，FastCGI 进程会等待接收所有的 PARAMS 和 标准输入数据包。 然后，在处理请求并将返回结果写入 标准输出（STDOUT） 流。处理完成后，发送一个空的数据包到标准输出来关闭这个流，并且会发送一个 END_REQUEST 类型消息通知 Web 服务器，告知它是否发生错误异常

<b>注意</b> 我们的 Web 服务器和 FastCGI 进程之间的连接可能处理多个请求，即一个连接可以处理多个请求.所以才需要采用数据包协议而不是直接使用单个数据流的原因：以实现「多路复用」

因此，由于每个数据包都包含唯一的 RequestID，所以 Web 服务器才能在一个连接上发送任意数量的请求，并且 FastCGI 进程也能够从一个连接上接收到任意数量的请求数据包。

另外我们还需要明确一点就是 Web 服务器 与 FastCGI 进程间通信是 无序的。即使我们在交互过程中看起来一个请求是有序的，但是我们的 Web 服务器也有可能在同一时间发出几十个 BEGIN_REQUEST 类型的数据包，以此类推

## php-cgi
从上面了解我们就可以知道了php-cgi其实就是一个cgi程序，php-cgi是php官方自带的一个FastCGI管理器，实现了FastCGI的协议（5.4以前，5.4后就是php-fpm），当php.ini修改后原有的php-cig不会生效（因为这些是提前fork的），只有当前的php-cgi销毁掉之后，新的才会生效，这样就不能平滑的过渡了。

## php-fpm
终于轮到我们的主角了，`php-fpm` 有人说php-fpm是php-cig的管理器，这是对的，但是好像也不全对，php-fpm其实还是一个fastcgi协议的实现，他可以看做一个实现了fastcgi协议的cig管理器。他可以动态的进行进程调度，这样的一个交互方式让php-cgi独立于httpd而存在。如果要让php-fpm以这种方式运行就需要`--enable-fpm`选项

## 最后NGINX如何与FastCgi协同工作
ginx 服务器无法直接与 FastCGI 服务器进行通信，需要启用 ngx_http_fastcgi_module 模块进行代理配置，才能将请求发送给 FastCGI 服务
其中，包括我们熟知的配置指令：

* fastcgi_pass 用于设置 FastCGI 服务器的 IP 地址（TCT 套接字）或 UNIX 套接字。
* fastcgi_param 设置传入 FastCGI 服务器的参数





## 结语
上面就是一个大概的php-fpm的原理的他的执行的一个流程，这一切是是互联网技术发展带来的结果。上面如有错误，欢迎大家指正。
