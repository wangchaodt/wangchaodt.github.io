---
title: 一致性Hash(转)
date: 2018-07-27 14:55:01
tags: [算法,hash,缓存]
categories: 其他
---
说道一致性Hash之前，我们要了解到redis或者mc缓存高可用，提高其读写性能，我们一般会进行主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离,一般的做法是hash取模分配到不同的机器上去,但是如果我们其中的一个集群服务器数量有变化的时候，这里的所有的缓存就会失效，会直接落到DB上去。所以就需要用一种新的算法来最大可能性减少机器增减的影响。
<!--more-->

## redis集群及Hahs的使用

我们现在的业务包括mysql或者redis都需要进行读写分离操作，同时每个读写都需要进行主从复制如下图所示
![](http://ww1.sinaimg.cn/large/65ca5a5cly1fu9eq3f9uwj20gq0aqmxd)
这是一个典型的集群，一个Master后挂载着多个Slave，这里的每个Slave的数据和Master是一致的，，但是如果这个集群的量开始大量增长的时候，大量的读操作会对集群造成很大的压力，这个时候我们就需要和mysql一样进行分库分表操作，在redis单中我们可以根据特定的字段进行hash取模来确定会落到那个集群但中去，比如我们有4个集群，这时候的我们需要更具uid分散均匀的缓存到各个集群中去
![](http://ww1.sinaimg.cn/large/65ca5a5cly1fu9f2caj4bj20ck0e1aar)
这样就可以直接根据hash后的值取模后的值落到相应的集群中去，这样速度很快，不需要选择遍历，但是这样也会有个很明显的缺点就是如果，我们4台服务器不能满足需求了，或者一台宕机了，这样的话所有的缓存就会出现问题，取模的值将会根据你服务器数量来决定，这样的话可能造成缓存时效，DB可能会承受流量洪峰。这时候Hash一致性算法便出现了。

## 什么是Hash一致性算法

一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下
![](http://ww1.sinaimg.cn/large/65ca5a5cly1fu9f8uo940j20ch0d0t8m)
整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环
下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：
![](http://ww1.sinaimg.cn/large/65ca5a5cly1fu9fa05gaqj20ju0k70t2)
例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：
![](http://ww1.sinaimg.cn/large/65ca5a5cly1fu9fbh99inj20jk0jzdgg)
根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。

## Hash一致性算法的容错特性

现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：
![](http://ww1.sinaimg.cn/large/65ca5a5cly1fu9fdb09h2j20jh0k4wf4)
下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：
![](http://ww1.sinaimg.cn/large/65ca5a5cly1fu9fdus72gj20jc0k23z8)
此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。

综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。

## Hash环的数据倾斜问题
一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：

![](http://ww1.sinaimg.cn/large/65ca5a5cly1fu9fgiabt3j20cc0d5dfy)
此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。

例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：
![](http://ww1.sinaimg.cn/large/65ca5a5cly1fu9fh4ky65j20k00kbaaj)
同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。


